(file_input      (seq (rep (or NEWLINE stmt)) ENDMARKER))

(funcdef         (seq "def" NAME parameters ":" suite))
(parameters      (seq "(" (opt paramlist) ")"))
(paramlist       (seq (seq NAME (rep (seq "," NAME))) (opt ",")))

(stmt            (or simple_stmt compound_stmt))
(simple_stmt     (seq (seq small_stmt (rep (seq ";" small_stmt))) (opt ";") NEWLINE))
(small_stmt      (or expr_stmt del_stmt pass_stmt flow_stmt global_stmt nonlocal_stmt assert_stmt))
(expr_stmt       (or (seq testlist augassign testlist) (seq testlist "=" testlist) tuple_or_test))
(augassign       (or "+=" "-=" "*=" "/=" "%=" "&=" "|=" "^=" "<<=" ">>=" "**=" "//="))
(del_stmt        (seq "del" star_expr))
(pass_stmt       "pass")
(flow_stmt       (or break_stmt continue_stmt return_stmt raise_stmt))
(break_stmt      "break")
(continue_stmt   "continue")
(return_stmt     (seq "return" (opt testlist)))
(raise_stmt      (seq "raise" (opt (seq test (opt (seq "from" test))))))
(global_stmt     (seq "global" NAME (rep (seq "," NAME))))
(nonlocal_stmt   (seq "nonlocal" NAME (rep (seq "," NAME))))
(assert_stmt     (seq "assert" test (opt (seq "," test))))

(compound_stmt   (or if_stmt while_stmt for_stmt try_stmt funcdef))
(if_stmt         (seq "if" test ":" suite (rep (seq "elif" test ":" suite)) (opt (seq "else" ":" suite))))
(while_stmt      (seq "while" test ":" suite (opt (seq "else" ":" suite))))
(for_stmt        (seq "for" NAME "in" test ":" suite (opt (seq "else" ":" suite))))
(try_stmt        (seq "try" ":" suite (or (seq (rep+ (seq except_clause ":" suite)) (opt (seq "else" ":" suite)) (opt (seq "finally" ":" suite))) (seq "finally" ":" suite))))
(except_clause   (seq "except" (opt (seq test (opt (seq "as" NAME))))))

(suite           (or simple_stmt (seq NEWLINE INDENT (rep+ stmt) DEDENT)))

(test            (or (seq or_test "if" or_test "else" test) or_test lambdef))
(lambdef         (seq "lambda" (opt paramlist) ":" test))
(or_test         (seq and_test (rep (seq "or" and_test))))
(and_test        (seq not_test (rep (seq "and" not_test))))
(not_test        (or (seq "not" not_test) comparison))
(comparison      (seq star_expr (rep (seq comp_op star_expr))))
(comp_op         (or "<" ">" "==" ">=" "<=" "<>" "!=" "in" (seq "not" "in") "is" (seq "is" "not")))
(star_expr       (seq (opt "*") expr))
(expr            (seq xor_expr (rep (seq "|" xor_expr))))
(xor_expr        (seq and_expr (rep (seq "^" and_expr))))
(and_expr        (seq shift_expr (rep (seq "&" shift_expr))))
(shift_expr      (seq arith_expr (rep (seq (or "<<" ">>") arith_expr))))
(arith_expr      (seq term (rep (seq (or "+" "-") term))))
(term            (seq factor (rep (seq (or "*" "/" "%" "//") factor))))
(factor          (or (seq (or "+" "-" "~") factor) power))
(indexed         (seq atom (rep trailer)))
(power           (seq indexed (opt (seq "**" factor))))
(atom            (or (seq "(" (opt tuple_or_test) ")") (seq "[" (opt testlist) "]") (seq "{" (opt dictorsetmaker) "}") NAME NUMBER (rep+ STRING) "..." "None" "True" "False"))

(trailer        (or (seq "(" (opt arglist) ")") (seq "[" tuple_or_test "]") (seq "." NAME)))
(testlist       (seq (seq test (rep (seq "," test))) (opt ",")))
(tuple_or_test  (seq test (rep (seq "," test)) (opt ",")))
(dictorsetmaker (or (seq (seq (seq test ":" test) (rep (seq "," test ":" test))) (opt ",")) (seq (seq test (rep (seq "," test))) (opt ","))))
(arglist        (seq (seq test (rep (seq "," test))) (opt ",")))

